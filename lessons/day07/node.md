### 数据类型和指针

数据类型是不占空间的
但是变量或常量是占内存空间的

二级指针

### typedef 的使用， 给类型命名别名

1. 定义类型的变量或常量
2. 在第一步的前边加上 typedef 关键字。这时候原来的常量或变量的名字就是原来数据类型的别名。
3. 使用类型别名定义常量或变量

```c
char *str_t; // str_t 是指针类型的变量
typedef char *str_t; // str_t 是指针类型的别名，但是对这种数据类型的变量的内容访问的时候，遵循的访问规则是 char
str_t s1,s2;
char *s1, *s2;
```

### 数组：

地址连续 多个元素 每个元素的数据类型相同

数组是一种数据类型 -> 自定义的数据类型

数组的名字就是数组的首地址

```c
int  arr[3]; // 可以访问
// 关于数组名称
// arr -> 常量
// arr 是 int[3] 数据类型

typedef int arr_t[3];
//arr_t 是int[3] 的数据类型的别名
arr_t a; a 是 int[3] 类型的变量

```

```c
int arr[3]; // 数组类型
int *arr[3]; // 指针数组类型

int *p = arr;
// *p = arr[0]
p+1 // (1个单位) p + 1 * (sizeof(int))
// *(p+1) = arr[1]

```

```c
char name[12];
// 字符串是字符数组的一个特例。
// 字符串是以 \0 结尾的
// 'a' 和 "a" 是不同的
// 'a': 占用一个字节 'a'
// "a": 占用两个字节 'a' '\0'

char str[0] = {'h', 'o', 'w', '\0', 'a', 's'};
printf("%s\n", str) // => how 遇到 \0 结束了


```

### 向量表(vector) 和 列表

1. 地址连续的都是向量表
2. 向量表属于列表
3. 地址不连续的也可以是列表

### 二维数组

```c
typedef int arr_t[3];// arr_t 是 数组类型
arr_t a; // a 是一个数组
arr_t b[2]; // b 是数组的名字 数组有两个元素构成， 每个元素也是一个数组类型， 里边包含3个int类型。
// 所以 b 是一个二维数组

int arr[2][3] = {{1,2,3},{4,5,6}};


arr_t *p; // p是指针类型的变量，p的地址空间里存放的是地址。对这个地址访问的时候，遵循 att_t 的规则。

p=arr;// p 和 arr 的区别？
// 1. p 是一个变量， arr是一个常量
// 数组的名字是常量，程序运行到数组定义的时候，为数组分配空间，这时空间已经确定。数组的名字代表的地址就已经确定了。不能改变了。

int (*arr)[3];
```

### 函数

函数： 为了解决问题，将计算机指令罗列到一起。

机制 + 策略

机制：明确这个函数的功能，切记一个函数只能完成一项功能。

如何使用函数，这是策略。

机制 + 策略 --> 机制

```c
// 1. 无参无返回值
void func(void){
  return;
}
// 2. 有参无返回值
void swap(int x, int y){
  return;
}
// 函数调用的时候，直接用实参初始化形参
void swap(int, int); // 函数的声明
void swap(int x, int y); // 函数的声明
void swap(int x, int y) { // 函数的声明和定义一起了。

}
```

### GDB 调试器的使用

```
如果使用 gdb调试器调试可执行程序，
那么这个可执行程序必须有调试信息。
如何给一个可执行程序添加调试符号呢？在编译的时候添加 -g 或者 -ggdb 这个参数。
gdb 可执行程序 开始启动 gdb 调试可执行程序
gdb 输出 gdb 调试命令
l list 列出程序的源码
b 行号或者函数名 设置断点
r run 运行程序到断点处
p 变量的名字 将变量内容输出
n next 执行下一条指令 如果是函数，直接执行函数完毕
q quit 退出 退出调试器
s step 如果下一条指令是函数调用，直接进入到函数里执行。
```
