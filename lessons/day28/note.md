## 管道

### 无名管道
使用无名管道通讯的进程, 必须是同一个进程开启的(父子/兄弟/...).

### 有名管道

创建一个文件 管道文件

特点 大小是 0

一个进程向管道文件写入数据, 如果没有进程读取管道文件里的数据, 这时候, 写操作就一直阻塞, 阻塞到有进程读取数据

如果没有进程向管道写入数据, 那么从管道文件里读取的操作也会一直阻塞.

```c
// 这是一个库函数, 不是系统调用.
int mkfifo(const char *path, mode_t mode);
```

### 区别
有名管道会记录在文件系统当中.无名管道不会.

## 信号
软中断 软件实现中断的概念.

计算机分为两种:
1. 中断
2. 异常

计算机分片 取指 译码 执行

### 中断
当一按键, 计算机就停止当前执行的事情, 先处理按键的指令, 然后再继续上述循环. 

### 异常
当计算机出现问题的时候, 会优先去处理异常, 如果处理完成, 

中断号 中断的处理程序
信号的编号 信号处理程序


### 中断和异常的区别
```shell
kill -l # 查看所有的信号
```
每个进程都可以接收到信号. 一共有62(少了 32 和 33号)个信号. 每个信号都有自己的信号处理函数.
不过一般理解为64个信号编号. 

跟信号编号对应的信号处理函数可以自定义  默认 / 忽略

我们的进程现在都是从 bash 启动的. 子进程继承父进程的信号处理程序. 

默认的情况下, 大部分是终止当前进程, 

在必要的情况下, 需要想进程注册一下信号处理函数. 

```c
void (*signal(int sig, void (*func)(int)))(int);
```

10) SIGUSR1 12) SIGUSR2 是系统提供的用户处理函数.


- 信号的产生
- 信号递送的过程 
- 信号的抵达 
- 信号的处理

### 信号的产生
1. 硬件产生信号 ctrl+c ctrl+\
2. 命令产生信号 kill -信号的编号 进程的pid   /  alarm(2)
3. 使用库函数或者系统调用产生信号 raise(3)


#### kill
```c
#include <stdio.h>
#include <signal.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
  kill(atoi(argv[2]), atoi(argv[1]));
  return 0;
}
```

#### 2. raise(3)
如何获取当前进程的pid
`getpid(2)`
```c
kill(getpid(), signum); // 等同于
```


#### 3. alarm(2)
在 seconds 秒后, 将 `SIGALRM` 信号递送给当前进程. 
如果 seconds=0, 将取消之前所有的闹钟.
```c
unsigned alarm(unsigned seconds);
pause()
```


### 信号的阻塞 和 未决信号集
信号集 信号的集合
```c
sigset_t set;
```



