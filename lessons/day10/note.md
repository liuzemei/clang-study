### 回顾

./a.out 做了什么？

1. 加载器将 a.out 程序加载到虚拟空间地址 -- 将编译的时候生成的符号的绝对地址，将这个符号加载到内存的指定位置。
2. 使用动态链接器检查 a.out 程序依赖的动态库，将依赖的动态库加载到虚拟地址空间。(找不到就报错)
3. 找到程序的入口 main 函数，开始执行程序

程序运行分为`加载`和`执行`两个过程
链接：静态链接、动态链接
静态链接发生在 编译链接生成可执行程序阶段。
动态链接发生在 程序加载到地址空间的时候。
-- 动态链接发生在程序运行阶段。

```shell
nm 二进制文件 # 二进制文件中的符号表
# 二进制文件符号：函数的名字 全局变量的名字 静态局部变量的名字
```

函数、全局变量、静态局部变量的地址空间已经确定了。
那函数中的形参和函数中的局部变量，执行到那条语句的时候，再为其分配地址空间。

```shell
ldd a.out # 查看动态链接库
```

程序执行的过程中完成动态库的加载 -- 动态加载

静态链接 发生在 编译生可执行文件期间
动态链接 发生在 程序运行期间

静态加载 发生在 程序执行之前
动态加载 发生在 程序执行期间

链接的过程是地址重定位的过程。

CPU 可以访问的地址空间：4G(32 位机)
1G 给了内核程序

静态存储区 程序运行之前
动态存储区 程序运行之后

### 生命周期

是一个时间维度的概念，从声明到销毁。

1. 函数的生命周期
   函数执行完毕，函数内变量(局部的)的空间就释放了。
2. 进程的生命周期
   进程执行完毕的时候，进程内变量(全局的)的空间就释放了。
   生成可执行文件之后 nm 出来有地址空间的，肯定是进程的生命周期。

### 作用域

是一个空间维度的概念，可访问。

1. 局部变量的作用域
   在从声明之后到局部的块内结束，可以访问。
2. 全局变量的生命周期
   在声明之后到整个文件末尾，可以访问。

### 预处理

将源文件作为预处理器的出入文件，初出文件为 .i 结尾的源文件。

1. 根据预处理指令对源文件进行相应的处理
2. 将注释信息取出
3. 增加文件的名字和行号

```shell
cpp 源文件 -o xxx.i
gcc -E 源文件 -o xxx.i
```

#### 预处理指令

预处理程序看到 `#include` 指令的时候，会将其后边的 <> 或 "" 里边的文件找到，然后将文件的内容复制、粘贴到指令所在位置

> 预处理指令不是 c 语句，所以，不用在行末加分号。

1. 文件的包含

```c
#include <> //
#include "" // 首先在当前路径下照，找不到，再到 <> 指定的路径下找
```

```shell
-I路径 # 将路径添加到 <> 指定的路径中
```

2. 宏定义

预处理程序看到宏定义时，就会把 c 语句中所有关于宏的使用，全部直接替换成值进行输出。

```c
// #define 宏名 替换的内容  宏定义
// #undef 宏名            解除宏
```

3. 条件编译

```c
//
#if
#else
#endif

// 如果定义了宏就执行 indef 下的语句
#ifdef 宏
#else
#endif


// 如果没有定义宏，就定义这个宏
#ifndef 宏
#define 宏
#endif

```

```shell
gcc xxx.c -DDEBUGE # 定义宏变量 DEBUG
```

4. 附加的宏
5. ...

### 头文件

内容：

1. 文件的包含
2. 宏定义
3. 类型的定义
4. 函数的声明
5. 变量的声明

变量的声明和变量的定义
变量的声明是要为变量分配内存空间的
变量的定义是变量作用域的扩充

类型的定义是起别名
